pipeline {
  agent any

  parameters {
    string(name: 'IMAGE_TAG', defaultValue: '', description: 'ECR tag produced by CI (example: git-fea78db or 123)')
    choice(name: 'ENV', choices: ['kind'], description: 'Target cluster/env (extend later: dev/stage/prod)')
    booleanParam(name: 'REFRESH_ECR_PULL_SECRET', defaultValue: true, description: 'Refresh ecr-secret in the target namespace')
  }

  environment {
    AWS_REGION  = "us-east-1"
    AWS_ACCOUNT = "168400405045"
    ECR_REPO    = "java-app"
    ECR_URI     = "${AWS_ACCOUNT}.dkr.ecr.${AWS_REGION}.amazonaws.com/${ECR_REPO}"

    K8S_NAMESPACE = "java-app"          // change if you use default
    APP_NAME      = "java-app"          // Deployment name
  }

  stages {

    stage('Checkout CD Repo') {
      steps {
        checkout scm
      }
    }

    stage('Validate Inputs') {
      steps {
        script {
          if (!params.IMAGE_TAG?.trim()) {
            error("IMAGE_TAG is required (example: git-fea78db).")
          }
        }
      }
    }

    stage('Verify Image Exists in ECR') {
      steps {
        sh """
          aws ecr describe-images \
            --region ${AWS_REGION} \
            --repository-name ${ECR_REPO} \
            --image-ids imageTag=${IMAGE_TAG} \
            --query 'imageDetails[0].imageDigest' \
            --output text
        """
      }
    }

    stage('Create Namespace (YAML)') {
      steps {
        sh """
          kubectl apply -f k8s/namespace.yaml
        """
      }
    }

    stage('Refresh ECR Pull Secret (Kind)') {
      when { expression { return params.REFRESH_ECR_PULL_SECRET } }
      steps {
        sh """
          TOKEN=\$(aws ecr get-login-password --region ${AWS_REGION})

          kubectl delete secret ecr-secret -n ${K8S_NAMESPACE} --ignore-not-found

          kubectl create secret docker-registry ecr-secret \
            -n ${K8S_NAMESPACE} \
            --docker-server=${AWS_ACCOUNT}.dkr.ecr.${AWS_REGION}.amazonaws.com \
            --docker-username=AWS \
            --docker-password="\$TOKEN"
        """
      }
    }

    stage('Render Manifests with Image') {
      steps {
        sh """
          mkdir -p rendered

          # Render deployment with correct image without modifying tracked file
          sed "s|REPLACE_IMAGE|${ECR_URI}:${IMAGE_TAG}|g" k8s/deployment.yaml > rendered/deployment.yaml

          # Copy other manifests as-is
          cp k8s/service.yaml rendered/service.yaml
          cp k8s/namespace.yaml rendered/namespace.yaml
        """
      }
    }

    stage('Apply to Kubernetes') {
      steps {
        sh """
          kubectl apply -f rendered/namespace.yaml
          kubectl apply -f rendered/deployment.yaml
          kubectl apply -f rendered/service.yaml
        """
      }
    }

    stage('Wait for Rollout') {
      steps {
        sh """
          kubectl rollout status deployment/${APP_NAME} -n ${K8S_NAMESPACE} --timeout=180s
          kubectl get pods -n ${K8S_NAMESPACE} -o wide
          kubectl get svc  -n ${K8S_NAMESPACE} -o wide
        """
      }
    }
  }
}
